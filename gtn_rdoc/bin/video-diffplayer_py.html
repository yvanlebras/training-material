<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>video-diffplayer.py - RDoc Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../";
  var index_rel_prefix = "../";
</script>

<script src="../js/navigation.js" defer></script>
<script src="../js/search.js" defer></script>
<script src="../js/search_index.js" defer></script>
<script src="../js/searcher.js" defer></script>
<script src="../js/darkfish.js" defer></script>

<link href="../css/fonts.css" rel="stylesheet">
<link href="../css/rdoc.css" rel="stylesheet">


<body id="top" role="document" class="file">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../table_of_contents.html#pages">Pages</a>
    <a href="../table_of_contents.html#classes">Classes</a>
    <a href="../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="project-metadata">
    
<div id="fileindex-section" class="nav-section">
  <h3>Pages</h3>

  <ul class="link-list">
    <li><a href="../bin/add_galaxy_instance_badges_py.html">add_galaxy_instance_badges.py</a>
    <li><a href="../bin/ari-gen-sample-audio_sh.html">ari-gen-sample-audio.sh</a>
    <li><a href="../bin/ari-make_sh.html">ari-make.sh</a>
    <li><a href="../bin/ari-quick_sh.html">ari-quick.sh</a>
    <li><a href="../bin/ari_sh.html">ari.sh</a>
    <li><a href="../bin/check-broken-boxes_py.html">check-broken-boxes.py</a>
    <li><a href="../bin/data-library-update_sh.html">data-library-update.sh</a>
    <li><a href="../bin/data_libarary_download_sh.html">data_libarary_download.sh</a>
    <li><a href="../bin/docker-install-tutorials_sh.html">docker-install-tutorials.sh</a>
    <li><a href="../bin/gtn-fix_sh.html">gtn-fix.sh</a>
    <li><a href="../bin/install_topic_requirements_sh.html">install_topic_requirements.sh</a>
    <li><a href="../bin/install_tutorial_requirements_sh.html">install_tutorial_requirements.sh</a>
    <li><a href="../bin/knit-automated_sh.html">knit-automated.sh</a>
    <li><a href="../bin/knit-frog_py.html">knit-frog.py</a>
    <li><a href="../bin/knit_py.html">knit.py</a>
    <li><a href="../bin/knittingneedles_py.html">knittingneedles.py</a>
    <li><a href="../bin/lint-diffs_py.html">lint-diffs.py</a>
    <li><a href="../bin/lunr-index_js.html">lunr-index.js</a>
    <li><a href="../bin/lunr-search_js.html">lunr-search.js</a>
    <li><a href="../bin/mergeyaml_py.html">mergeyaml.py</a>
    <li><a href="../bin/prepare_docker_checks_py.html">prepare_docker_checks.py</a>
    <li><a href="../bin/publish-archive.html">publish-archive</a>
    <li><a href="../bin/schema-contributors_yaml.html">schema-contributors.yaml</a>
    <li><a href="../bin/schema-faq_yaml.html">schema-faq.yaml</a>
    <li><a href="../bin/schema-learning-pathway_yaml.html">schema-learning-pathway.yaml</a>
    <li><a href="../bin/schema-news_yaml.html">schema-news.yaml</a>
    <li><a href="../bin/schema-quiz_yaml.html">schema-quiz.yaml</a>
    <li><a href="../bin/schema-requirement-external_yaml.html">schema-requirement-external.yaml</a>
    <li><a href="../bin/schema-requirement-internal_yaml.html">schema-requirement-internal.yaml</a>
    <li><a href="../bin/schema-slides_yaml.html">schema-slides.yaml</a>
    <li><a href="../bin/schema-topic_yaml.html">schema-topic.yaml</a>
    <li><a href="../bin/schema-tutorial_yaml.html">schema-tutorial.yaml</a>
    <li><a href="../bin/setup_training_content_py.html">setup_training_content.py</a>
    <li><a href="../bin/slides-fix_css.html">slides-fix.css</a>
    <li><a href="../bin/supported-fetch_py.html">supported-fetch.py</a>
    <li><a href="../bin/validate-has-workflow_sh.html">validate-has-workflow.sh</a>
    <li><a href="../bin/video-browser-recorder_js.html">video-browser-recorder.js</a>
    <li><a href="../bin/video-builder_py.html">video-builder.py</a>
    <li><a href="../bin/video-diffplayer_py.html">video-diffplayer.py</a>
    <li><a href="../bin/video-extract-script_py.html">video-extract-script.py</a>
    <li><a href="../bin/video-term-demo-magic_sh.html">video-term-demo-magic.sh</a>
    <li><a href="../bin/video-term-recorder_sh.html">video-term-recorder.sh</a>
    <li><a href="../bin/yaml2json_py.html">yaml2json.py</a>
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-label="Page bin/video-diffplayer.py">

<p>#!/usr/bin/env python3 “”“Simple curses-based text editor.</p>

<p>This code is based on <a href="https://github.com/tdryer/editor">github.com/tdryer/editor</a> by tdryer. The original code is licensed under MIT:</p>

<p>The MIT License (MIT)</p>

<p>Copyright © 2014 Tom Dryer</p>

<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>

<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>

<p>THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. “”“ import time import argparse from contextlib import contextmanager import whatthepatch import sys import curses import os CHAR_ESC = 27 CHAR_BKSP = 127</p>

<p>class Buffer(object):</p>

<pre>&quot;&quot;&quot;The basic data structure for editable text.

The buffer is column and row oriented. Column and row numbers start with 0.
A buffer always has at least one row. All positions within a buffer specify
a position between characters.
&quot;&quot;&quot;

def __init__(self, text=&#39;&#39;):
    &quot;&quot;&quot;Create a new Buffer, optionally initialized with text.&quot;&quot;&quot;
    self._lines = text.split(&#39;\n&#39;)

def get_lines(self):
    &quot;&quot;&quot;Return list of lines in the buffer.&quot;&quot;&quot;
    return list(self._lines) # return a copy

def _check_point(self, row, col):
    &quot;&quot;&quot;Raise ValueError if the given row and col are not a valid point.&quot;&quot;&quot;
    if row &lt; 0 or row &gt; len(self._lines) - 1:
        raise ValueError(&quot;Invalid row: &#39;{}&#39;&quot;.format(row))
    cur_row = self._lines[row]
    if col &lt; 0 or col &gt; len(cur_row):
        raise ValueError(&quot;Invalid col: &#39;{}&#39;&quot;.format(col))

def set_text(self, row1, col1, row2, col2, text):
    &quot;&quot;&quot;Set the text in the given range.

    The end of the range is exclusive (to allow inserting text without
    removing a single character). Column numbers are positions between
    characters.

    Raises ValueError if the range is invalid.
    &quot;&quot;&quot;
    # TODO check that point2 is after or the same as point1
    self._check_point(row1, col1)
    self._check_point(row2, col2)

    line = self._lines[row1][:col1] + text + self._lines[row2][col2:]
    self._lines[row1:row2+1] = line.split(&#39;\n&#39;)</pre>

<p>class EditorGUI(object):</p>

<pre>def __init__(self, stdscr, filename, stream=None, speed=0, nosave=False, seshlen=0):
    &quot;&quot;&quot;Create the GUI with curses screen and optional filename to load.&quot;&quot;&quot;
    self._stdscr = stdscr

    # if filename already exists, try to load from it
    text = &#39;&#39;
    if filename != None and os.path.isfile(filename):
        with open(filename) as f:
            text = f.read()

    self._filename = filename
    self._buf = Buffer(text)
    self._row = 0
    self._col = 0
    self._scroll_top = 0 # the first line number in the window
    self._mode = &#39;normal&#39;
    self._message = &#39;&#39;
    self._will_exit = False
    # Extras
    self._char_stream = stream
    self._speed = speed
    self._nosave = nosave
    self._seshlen = seshlen
    self._start_time = time.time()

def _draw_gutter(self, num_start, num_rows, last_line_num):
    &quot;&quot;&quot;Draw the gutter, and return the gutter width.&quot;&quot;&quot;
    line_nums = list(range(num_start, num_start + num_rows))
    assert len(line_nums) == num_rows
    gutter_width = max(3, len(str(last_line_num))) + 1
    for y, line_num in enumerate(line_nums):
        if line_num &gt; last_line_num:
            text = &#39;~&#39;.ljust(gutter_width)
        else:
            text = &#39;{} &#39;.format(line_num).rjust(gutter_width)
        self._stdscr.addstr(y, 0, text, curses.A_REVERSE)
    return gutter_width

def _draw(self):
    &quot;&quot;&quot;Draw the GUI.&quot;&quot;&quot;
    self._stdscr.erase()
    height = self._stdscr.getmaxyx()[0]
    width = self._stdscr.getmaxyx()[1]
    # self._draw_status_line(0, height - 1, width)
    self._draw_text(0, 0, width, height - 1)
    self._stdscr.refresh()

def _draw_status_line(self, left, top, width):
    &quot;&quot;&quot;Draw the status line.&quot;&quot;&quot;
    # TODO: can&#39;t write to bottom right cell
    mode = &#39;{} {} {}&#39;.format(self._filename, self._mode.upper(),
                             self._message).ljust(width - 1)
    self._stdscr.addstr(top, left, mode, curses.A_REVERSE)
    position = &#39;LN {}:{} &#39;.format(self._row + 1, self._col + 1)
    self._stdscr.addstr(top, left + width - 1 - len(position), position,
                        curses.A_REVERSE)

def _get_num_wrapped_lines(self, line_num, width):
    &quot;&quot;&quot;Return the number of lines the given line number wraps to.&quot;&quot;&quot;
    return len(self._get_wrapped_lines(line_num, width))

def _get_wrapped_lines(self, line_num, width, convert_nonprinting=True):
    &quot;&quot;&quot;Return the wrapped lines for the given line number.&quot;&quot;&quot;
    def wrap_text(text, width):
        &quot;&quot;&quot;Wrap string text into list of strings.&quot;&quot;&quot;
        if text == &#39;&#39;:
            yield &#39;&#39;
        else:
            for i in range(0, len(text), width):
                yield text[i:i + width]
    assert line_num &gt;= 0, &#39;line_num must be &gt; 0&#39;
    line = self._buf.get_lines()[line_num]
    if convert_nonprinting:
        line = self._convert_nonprinting(line)
    return list(wrap_text(line, width))

def _scroll_bottom_to_top(self, bottom, width, height):
    &quot;&quot;&quot;Return the first visible line&#39;s number so bottom line is visible.&quot;&quot;&quot;
    def verify(top):
        &quot;&quot;&quot;Verify the result of the parent function is correct.&quot;&quot;&quot;
        rows = [list(self._get_wrapped_lines(n, width))
                for n in range(top, bottom + 1)]
        num_rows = sum(len(r) for r in rows)
        assert top &lt;= bottom, (&#39;top line {} may not be below bottom {}&#39;
                               .format(top, bottom))
        assert num_rows &lt;= height, (
            &#39;{} rows between {} and {}, but only {} remaining. rows are {}&#39;
            .format(num_rows, top, bottom, height, rows))

    top, next_top = bottom, bottom
    # distance in number of lines between top and bottom
    distance = self._get_num_wrapped_lines(bottom, width)

    # move top upwards as far as possible
    while next_top &gt;= 0 and distance &lt;= height:
        top = next_top
        next_top -= 1
        distance += self._get_num_wrapped_lines(max(0, next_top), width)

    verify(top)
    return top

def _scroll_to(self, line_num, width, row_height):
    &quot;&quot;&quot;Scroll so the line with the given number is visible.&quot;&quot;&quot;
    # lowest scroll top that would still keep line_num visible
    lowest_top = self._scroll_bottom_to_top(line_num, width, row_height)

    if line_num &lt; self._scroll_top:
        # scroll up until line_num is visible
        self._scroll_top = line_num
    elif self._scroll_top &lt; lowest_top:
        # scroll down to until line_num is visible
        self._scroll_top = lowest_top

@staticmethod
def _convert_nonprinting(text):
    &quot;&quot;&quot;Replace nonprinting character in text.&quot;&quot;&quot;
    # TODO: it would be nice if these could be highlighted when displayed
    res = []
    for char in text:
        i = ord(char)
        if char == &#39;\t&#39;:
            res.append(&#39;-&gt;  &#39;)
        elif i &lt; 32 or i &gt; 126:
            res.append(&#39;&lt;{}&gt;&#39;.format(hex(i)[2:]))
        else:
            res.append(char)
    return &#39;&#39;.join(res)

def _draw_text(self, left, top, width, height):
    &quot;&quot;&quot;Draw the text area.&quot;&quot;&quot;
    # TODO: handle single lines that occupy the entire window
    highest_line_num = len(self._buf.get_lines())
    gutter_width = max(3, len(str(highest_line_num))) + 1
    line_width = width - gutter_width # width to which text is wrapped
    cursor_y, cursor_x = None, None # where the cursor will be drawn

    # set scroll_top so the cursor is visible
    self._scroll_to(self._row, line_width, height)

    line_nums = list(range(self._scroll_top, highest_line_num))
    cur_y = top
    trailing_char = &#39;~&#39;

    for line_num in line_nums:

        # if there are no more rows left, break
        num_remaining_rows = top + height - cur_y
        if num_remaining_rows == 0:
            break

        # if all the wrapped lines can&#39;t fit on screen, break
        wrapped_lines = self._get_wrapped_lines(line_num, line_width)
        if len(wrapped_lines) &gt; num_remaining_rows:
            trailing_char = &#39;@&#39;
            break

        # calculate cursor position if cursor must be on this line
        if line_num == self._row:
            lines = self._get_wrapped_lines(line_num, line_width,
                                            convert_nonprinting=False)
            real_col = len(self._convert_nonprinting(
                &#39;&#39;.join(lines)[:self._col])
            )
            cursor_y = cur_y + real_col / line_width
            cursor_x = left + gutter_width + real_col % line_width

        # draw all the wrapped lines
        for n, wrapped_line in enumerate(wrapped_lines):
            if n == 0:
                gutter = &#39;{} &#39;.format(line_num + 1).rjust(gutter_width)
            else:
                gutter = &#39; &#39; * gutter_width
            self._stdscr.addstr(cur_y, left, gutter, curses.A_REVERSE)
            self._stdscr.addstr(cur_y, left + len(gutter), wrapped_line)
            cur_y += 1

    # draw empty lines
    for cur_y in range(cur_y, top + height):
        gutter = trailing_char.ljust(gutter_width)
        self._stdscr.addstr(cur_y, left, gutter)

    # position the cursor
    assert cursor_x != None and cursor_y != None
    self._stdscr.move(int(cursor_y) + 0, int(cursor_x) + 0)

def _handle_normal_keypress(self, char):
    &quot;&quot;&quot;Handle a keypress in normal mode.&quot;&quot;&quot;
    if char == ord(&#39;q&#39;): # quit
        self._will_exit = True
    elif char == ord(&#39;j&#39;): # down
        self._row += 1
    elif char == ord(&#39;k&#39;): # up
        self._row -= 1
    elif char == ord(&#39;h&#39;): # left
        self._col -= 1
    elif char == ord(&#39;l&#39;): # right
        self._col += 1
    elif char == ord(&#39;0&#39;): # move to beginning of line
        self._col = 0
    elif char == ord(&#39;$&#39;): # move to end of line
        cur_line_len = len(self._buf.get_lines()[self._row])
        self._col = cur_line_len - 1
    elif char == ord(&#39;x&#39;): # delete a character
        self._buf.set_text(self._row, self._col, self._row,
                            self._col + 1, &#39;&#39;)
    elif char == ord(&#39;i&#39;): # enter insert mode
        self._mode = &quot;insert&quot;
    elif char == ord(&#39;a&#39;): # enter insert mode after cursor
        self._mode = &quot;insert&quot;
        self._col += 1
    elif char == ord(&#39;o&#39;): # insert line after current
        cur_line_len = len(self._buf.get_lines()[self._row])
        self._buf.set_text(self._row, cur_line_len, self._row,
                           cur_line_len, &#39;\n&#39;)
        self._row += 1
        self._col = 0
        self._mode = &quot;insert&quot;
    elif char == ord(&#39;O&#39;): # insert line before current
        self._buf.set_text(self._row, 0, self._row, 0, &#39;\n&#39;)
        self._col = 0
        self._mode = &quot;insert&quot;
    elif char == ord(&#39;w&#39;): # write file
        if self._filename == None:
            self._message = &#39;Can\&#39;t write file without filename.&#39;
        else:
            try:
                with open(self._filename, &#39;w&#39;) as f:
                    f.write(&#39;\n&#39;.join(self._buf.get_lines()))
            except IOError as e:
                self._message = (&#39;Failed to write file \&#39;{}\&#39;: {}&#39;
                                 .format(self._filename, e))
    else:
        self._message = &#39;Unknown key: {}&#39;.format(char)

def _handle_insert_keypress(self, char):
    &quot;&quot;&quot;Handle a keypress in insert mode.&quot;&quot;&quot;
    if char == CHAR_ESC:
        # leaving insert mode moves cursor left
        if self._mode == &#39;insert&#39;:
            self._col -= 1
        self._mode = &quot;normal&quot;
    elif char == CHAR_BKSP: # backspace
        if self._col == 0 and self._row == 0:
            pass # no effect
        elif self._col == 0:
            # join the current line with the previous one
            prev_line = self._buf.get_lines()[self._row - 1]
            cur_line = self._buf.get_lines()[self._row]
            self._buf.set_text(self._row - 1, 0, self._row,
                                len(cur_line), prev_line + cur_line)
            self._col = len(prev_line)
            self._row -= 1
        else:
            # remove the previous character
            self._buf.set_text(self._row, self._col - 1, self._row,
                                self._col, &#39;&#39;)
            self._col -= 1
    else:
        self._message = (&#39;inserted {} at row {} col {}&#39;
                         .format(char, self._row, self._col))
        self._buf.set_text(self._row, self._col, self._row,
                            self._col, chr(char))
        if chr(char) == &#39;\n&#39;:
            self._row += 1
            self._col = 0
        else:
            self._col += 1

def main(self):
    &quot;&quot;&quot;GUI main loop.&quot;&quot;&quot;

    # Reverse to permit popping
    if self._char_stream is not None:
        stream = self._char_stream[::-1]
        automated = True
    else:
        automated = False

    while not self._will_exit:
        self._draw()
        self._message = &#39;&#39;

        time.sleep(self._speed)
        if automated:
            if len(stream) &gt; 0:
                if len(stream) == len(self._char_stream):
                    # Pause before starting
                    time.sleep(2)
                char = stream.pop()
            else:
                # Push write and quit
                stream.append(ord(&#39;q&#39;))
                if not self._nosave:
                    stream.append(ord(&#39;w&#39;))
                # Pause before writing/exiting
                now = time.time()
                elapsed_time = now - self._start_time
                if self._seshlen &gt; elapsed_time:
                    time.sleep(self._seshlen - elapsed_time)
                else:
                    time.sleep(2)
        else:
            char = self._stdscr.getch()

        if self._mode == &#39;normal&#39;:
            self._handle_normal_keypress(char)
        elif self._mode == &#39;insert&#39;:
            self._handle_insert_keypress(char)

        # TODO: get rid of this position clipping
        num_lines = len(self._buf.get_lines())
        # This is a workaround. If we press &#39;j&#39; on the last line, it will
        # add another new line for us. This works around having to figure
        # out if we&#39;re on the last line to add a new line.
        row_max = min(num_lines - 1, max(0, self._row))
        if self._row &gt; row_max:
            self._buf._lines.append(&#39;&#39;)
        self._row = min(num_lines, max(0, self._row))

        # on empty lines, still allow col 1
        num_cols = max(1, len(self._buf.get_lines()[self._row]))
        # in insert mode, allow using append after the last char
        if self._mode == &#39;insert&#39;:
            num_cols += 1
        self._col = min(num_cols - 1, max(0, self._col))</pre>

<p>@contextmanager def use_curses():</p>

<pre>&quot;&quot;&quot;Context manager to set up and tear down curses.&quot;&quot;&quot;
stdscr = curses.initscr()
curses.noecho() # do not echo keys
curses.cbreak() # don&#39;t wait for enter
try:
    yield stdscr
finally:
    # clean up and exit
    curses.nocbreak()
    stdscr.keypad(0)
    curses.echo()
    curses.endwin()</pre>

<p>def move(target, current):</p>

<pre>n = target - current
if target &gt; current:
    return (n, [&#39;j&#39;] * n)
elif target &lt; current:
    return (n, [&#39;k&#39;] * n)
else:
    return (n, []) # On correct line</pre>

<p>def curses_main():</p>

<pre>&quot;&quot;&quot;Start the curses GUI.&quot;&quot;&quot;
parser = argparse.ArgumentParser(description=&#39;Process some integers.&#39;)
parser.add_argument(&#39;--diff&#39;, type=argparse.FileType(&#39;r&#39;), help=&quot;Path to the diff to apply&quot;)
parser.add_argument(&#39;--file&#39;, type=argparse.FileType(&#39;r&#39;), help=&quot;Path to file to edit (conflicts with --dif)&quot;)
parser.add_argument(&#39;--speed&#39;, type=float, default=0.01, help=&quot;Time to sleep between button presses&quot;)
parser.add_argument(&#39;--session-min-length&#39;, type=float, default=0, help=&quot;The minimum time of the recording session (for syncing with audio.) Will sleep until this time has been reached.&quot;)
parser.add_argument(&#39;--debug&#39;, action=&#39;store_true&#39;, help=&quot;Print out character stream and exit&quot;)
parser.add_argument(&#39;--nosave&#39;, action=&#39;store_true&#39;, help=&quot;Do not save the output&quot;)
args = parser.parse_args()

stream = None
fn = None
if args.file:
    fn = args.file.name

if args.diff:
    p = list(whatthepatch.parse_patch(args.diff.read()))

    if len(p) != 1:
        raise Exception(&quot;Uhh can&#39;t parse this&quot;)

    (header, changes, text) = p[0]
    stream = []
    fn = header.new_path
    if header.new_path == &#39;/dev/null&#39;:
        raise Exception(&#39;Removing files is unsupported!&#39;)
    elif header.old_path == &#39;/dev/null&#39; or header.old_path == header.new_path:
        # If there is a set of folders, we need to make it.
        if &#39;/&#39; in header.new_path:
            directory = os.path.dirname(header.new_path)
            os.makedirs(directory, exist_ok=True)

        current_line = 1
        line_delta = 0
        for c in changes:
            if c.new is None:
                if args.debug:
                    stream.append(f&#39;CASE A/- move {c.old + line_delta}&lt;-{current_line}&#39;)
                # print(f&#39;removing line {c.old}: {c.line}&#39;)
                (motion_count, motions) = move(c.old + line_delta, current_line)
                stream.extend(motions)
                current_line += motion_count

                stream.extend([&#39;x&#39;] * len(c.line))
                stream.extend([&#39;i&#39;, chr(CHAR_BKSP), chr(CHAR_ESC), &#39;0&#39;])
                current_line -= 1
                line_delta -= 1

            elif c.old is None:
                if args.debug:
                    stream.append(f&#39;CASE B/+ move {c.new}&lt;-{current_line}&#39;)
                (motion_count, motions) = move(c.new, current_line)
                stream.extend(motions)
                current_line = c.new

                stream.append(&#39;O&#39;) # Enter edit mode
                stream.extend(c.line)
                stream.append(chr(CHAR_ESC)) # Return to normal
                stream.append(&#39;0&#39;) # Ensure at start of line
            else:
                line_delta = c.new - c.old
                # if args.debug:
                    # stream.append(&#39;CASE C/=&#39;)
                # stream.extend(move(c.new, current_line))
                # current_line = c.new

                pass
                # print(f&#39;No change?? {c.old} {c.new} {c.line}&#39;)
            if args.debug:
                print(c)
                stream.append(f&#39;DEBUG: {current_line}/{line_delta}&#39;)
                print(stream)
                stream = []
    else:
        raise Exception(&quot;Cannot handle renames&quot;)

    if args.debug:
        print(stream)
        sys.exit()

    # Just in case.
    stream.append(chr(CHAR_ESC))
    stream = list(map(ord, stream))

with use_curses() as stdscr:
    gui = EditorGUI(stdscr, fn, stream=stream, speed=args.speed, nosave=args.nosave, seshlen=args.session_min_length)
    gui.main()</pre>

<p>if __name__ == &#39;__main__&#39;:</p>

<pre class="ruby"><span class="ruby-identifier">curses_main</span>()
</pre>

</main>



<footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.3.3.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

