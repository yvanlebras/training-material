<!DOCTYPE html>
<html>











  <head>
    <meta charset="utf-8">
    <title>Unicycler Assembly</title>
    
        <script async defer data-domain="training.galaxyproject.org" src="https://plausible.galaxyproject.eu/js/plausible.js"></script>

    
    <link rel="stylesheet" href="/training-material/assets/css/slides.css">
    <script src="https://kit.fontawesome.com/67b3f98409.js" crossorigin="anonymous"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="/training-material/favicon.ico" type="image/x-icon" />

    
    
    
    
    <meta name="description" content="DNA sequence data has become an indispensable tool for Mo..." />
    <meta property="og:title" content="Galaxy Training: Unicycler Assembly" />
    <meta property="og:description" content="DNA sequence data has become an indispensable tool for Mo..." />
    <meta property="og:image" content="/training-material/assets/images/GTNLogo1000.png" />
    <script type="application/ld+json">
      


{
  "@context": "http://schema.org",
  "@type": "Course",
  "accessMode": [
    "textual",
    "visual"
  ],
  "accessModeSufficient": [
    "textual",
    "visual"
  ],
  "accessibilityControl": [
    "fullKeyboardControl",
    "fullMouseControl"
  ],
  "accessibilityFeature": [
    "alternativeText",
    "tableOfContents"
  ],
  "accessibilitySummary": "Short descriptions are present but long descriptions will be needed for non-visual users",
  "audience": {
    "@type": "EducationalAudience",
    "educationalRole": "students"
  },
  "citation": {
    "@type": "CreativeWork",
    "name": "Community-Driven Data Analysis Training for Biology",
    "url": "https://doi.org/10.1016/j.cels.2018.05.012"
  },
  "copyrightHolder": {
    "@type": "Organization",
    "email": "galaxytrainingnetwork@gmail.com",
    "name": "Galaxy Training Network",
    "url": "https://galaxyproject.org/teach/gtn/"
  },
  "dateModified": "1970-01-01 00:33:41 +0000",
  "discussionUrl": "https://gitter.im/Galaxy-Training-Network/Lobby",
  "headline": "Unicycler Assembly",
  "interactivityType": "mixed",
  "isAccessibleForFree": true,
  "isFamilyFriendly": true,
  "license": "https://spdx.org/licenses/CC-BY-4.0.html",
  "producer": {
    "@type": "Organization",
    "email": "galaxytrainingnetwork@gmail.com",
    "name": "Galaxy Training Network",
    "url": "https://galaxyproject.org/teach/gtn/"
  },
  "provider": {
    "@type": "Organization",
    "email": "galaxytrainingnetwork@gmail.com",
    "name": "Galaxy Training Network",
    "url": "https://galaxyproject.org/teach/gtn/"
  },
  "sourceOrganization": {
    "@type": "Organization",
    "email": "galaxytrainingnetwork@gmail.com",
    "name": "Galaxy Training Network",
    "url": "https://galaxyproject.org/teach/gtn/"
  },
  "isPartOf": {
    "@type": "CreativeWork",
    "name": "Assembly",
    "description": "DNA sequence data has become an indispensable tool for Molecular Biology & Evolutionary Biology. Study in these fields now require a genome sequence to work from. We call this a 'Reference Sequence.' We need to build a reference for each species. We do this by Genome Assembly. De novo Genome Assembly is the process of reconstructing the original DNA sequence from the fragment reads alone.",
    "url": "https://training.galaxyproject.org//training-material/topics/assembly/"
  },
  "courseCode": "assembly / unicycler-assembly / slides",
  "learningResourceType": "slides",
  "name": "Slides for 'Unicycler Assembly' tutorial",
  "url": "https://training.galaxyproject.org//training-material/topics/assembly/tutorials/unicycler-assembly/slides.html",
  "timeRequired": "PT4H",
  "keywords": "prokaryote",
  "description": "The questions this  addresses are:\n - I have short reads and long reads. How do I assemble a genome?\n\n\\nThe objectives are:\n - Perform Quality Control on your reads\n - Perform a Small genome Assembly with Unicycler\n - Evaluate the Quality of the Assembly with Quast\n - Annotate the assembly with Prokka\n\n",
  "inLanguage": {
    "@type": "Language",
    "name": "English",
    "alternateName": "en"
  },
  "coursePrerequisites": [
    {
      "@type": "CreativeWork",
      "url": "https://training.galaxyproject.org//training-material/topics/introduction/",
      "name": "Introduction to Galaxy Analyses",
      "description": "Introduction to Galaxy Analyses",
      "provider": {
        "@type": "Organization",
        "email": "galaxytrainingnetwork@gmail.com",
        "name": "Galaxy Training Network",
        "url": "https://galaxyproject.org/teach/gtn/"
      }
    },
    {
      "@type": "Course",
      "url": "https://training.galaxyproject.org//training-material/topics/sequence-analysis/tutorials/quality-control/slides.html",
      "name": "Quality Control",
      "description": "Slides for 'Quality Control' tutorial",
      "learningResourceType": "slides",
      "interactivityType": "expositive",
      "provider": {
        "@type": "Organization",
        "email": "galaxytrainingnetwork@gmail.com",
        "name": "Galaxy Training Network",
        "url": "https://galaxyproject.org/teach/gtn/"
      }
    },
    {
      "@type": "Course",
      "url": "https://training.galaxyproject.org//training-material/topics/sequence-analysis/tutorials/quality-control/tutorial.html",
      "name": "Quality Control",
      "description": "Hands-on for 'Quality Control' tutorial",
      "learningResourceType": "hands-on tutorial",
      "interactivityType": "expositive",
      "provider": {
        "@type": "Organization",
        "email": "galaxytrainingnetwork@gmail.com",
        "name": "Galaxy Training Network",
        "url": "https://galaxyproject.org/teach/gtn/"
      }
    },
    {
      "@type": "Course",
      "url": "https://training.galaxyproject.org//training-material/topics/sequence-analysis/tutorials/quality-control/slides.html",
      "name": "Quality Control",
      "description": "Slides for 'Quality Control' tutorial",
      "learningResourceType": "slides",
      "interactivityType": "expositive",
      "provider": {
        "@type": "Organization",
        "email": "galaxytrainingnetwork@gmail.com",
        "name": "Galaxy Training Network",
        "url": "https://galaxyproject.org/teach/gtn/"
      }
    }
  ],
  "hasPart": [

  ],
  "author": [
    {
      "@type": "Person",
      "name": "Anton Nekrutenko"
    },
    {
      "@type": "Person",
      "name": "Delphine Lariviere"
    },
    {
      "@type": "Person",
      "name": "Simon Gladman"
    }
  ],
  "contributor": [
    {
      "@type": "Person",
      "name": "Anton Nekrutenko"
    },
    {
      "@type": "Person",
      "name": "Delphine Lariviere"
    },
    {
      "@type": "Person",
      "name": "Simon Gladman"
    }
  ],
  "about": [
    {
      "@type": "CreativeWork",
      "name": "Assembly",
      "description": "DNA sequence data has become an indispensable tool for Molecular Biology & Evolutionary Biology. Study in these fields now require a genome sequence to work from. We call this a 'Reference Sequence.' We need to build a reference for each species. We do this by Genome Assembly. De novo Genome Assembly is the process of reconstructing the original DNA sequence from the fragment reads alone.",
      "url": "https://training.galaxyproject.org//training-material/topics/assembly/"
    }
  ]
}
    </script>
    <script type="text/javascript" src="/training-material/assets/js/jquery.slim.min.js"></script>
  </head>
  <body>
    <textarea id="source">
name: inverse
layout: true
class: center, middle, inverse

<div class="my-header"><span>
<a href="/training-material/topics/assembly" title="Return to topic page" ><i class="fa fa-level-up" aria-hidden="true"></i></a>

<a class="nav-link" href="https://github.com/galaxyproject/training-material/edit/main/topics/assembly/tutorials/unicycler-assembly/slides.html"><i class="fa fa-pencil" aria-hidden="true"></i></a>

</span></div>

<div class="my-footer"><span>

<img src="/training-material/assets/images/GTN-60px.png" alt="Galaxy Training Network" style="height: 40px;"/>

</span></div>

---



<img src="/training-material/assets/images/GTN.png" alt="Galaxy Training Network" class="cover-logo"/>


# Unicycler Assembly


<div class="contributors-line">

<a href="/training-material/hall-of-fame/nekrut/" class="contributor-badge contributor-nekrut"><img src="https://avatars.githubusercontent.com/nekrut?s=27" alt="Avatar">Anton Nekrutenko</a>


<a href="/training-material/hall-of-fame/delphine-l/" class="contributor-badge contributor-delphine-l"><img src="https://avatars.githubusercontent.com/delphine-l?s=27" alt="Avatar">Delphine Lariviere</a>


<a href="/training-material/hall-of-fame/slugger70/" class="contributor-badge contributor-slugger70"><img src="https://avatars.githubusercontent.com/slugger70?s=27" alt="Avatar">Simon Gladman</a>


<a href="https://training.galaxyproject.org/training-material/topics/contributing/" class="contributor-badge contributor-newcontributors"><i class="fas fa-users" aria-hidden="true"></i><span class="visually-hidden">hall-of-fame</span>Add Contributions!</a>


</div>


<div class="footnote" style="bottom: 4 em;"><i class="far fa-calendar" aria-hidden="true"></i><span class="visually-hidden">last_modification</span> Updated: Jul 9, 2021</div>

<div class="footnote" style="bottom: 2.5em;"><i class="fas fa-file-alt" aria-hidden="true"></i><span class="visually-hidden">text-document</span><a href="slides-plain.html"> Plain-text slides</a></div>
<div class="footnote" style="bottom: 1em;"><strong>Tip: </strong>press <kbd>P</kbd> to view the presenter notes</div>

???
Presenter notes contain extra information which might be useful if you intend to use these slides for teaching.

Press `P` again to switch presenter notes off

Press `C` to create a new window where the same presentation will be displayed.
This window is linked to the main window. Changing slides on one will cause the
slide to change on the other.

Useful when presenting.



---

## Requirements

Before diving into this slide deck, we recommend you to have a look at:



    
        
        
            
        
- [Introduction to Galaxy Analyses](/training-material/topics/introduction)
    

    
        
        
            
        
- [Sequence analysis](/training-material/topics/sequence-analysis)
    - Quality Control: [<i class="fab fa-slideshare" aria-hidden="true"></i><span class="visually-hidden">slides</span> slides](/training-material/topics/sequence-analysis/tutorials/quality-control/slides.html) - [<i class="fas fa-laptop" aria-hidden="true"></i><span class="visually-hidden">tutorial</span> hands-on](/training-material/topics/sequence-analysis/tutorials/quality-control/tutorial.html)
    






---







### &lt;i class=&quot;far fa-question-circle&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;span class=&quot;visually-hidden&quot;&gt;question&lt;/span&gt; Questions


- I have short reads and long reads. How do I assemble a genome?


---



### &lt;i class=&quot;fas fa-bullseye&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;span class=&quot;visually-hidden&quot;&gt;objectives&lt;/span&gt; Objectives


- Perform Quality Control on your reads

- Perform a Small genome Assembly with Unicycler

- Evaluate the Quality of the Assembly with Quast

- Annotate the assembly with Prokka


---


# Small Genome Assembly With Unicycler

---
.enlarge120[

# **Introduction to Genome Assembly**

]



To start on Genome assembly you can read the previous assembly tutorials:
* [Introduction to Genome Assembly](https://galaxyproject.github.io/training-material/topics/assembly/tutorials/general-introduction/slides.html#1)
* [De Bruijn Graph Assembly](https://galaxyproject.github.io/training-material/topics/assembly/tutorials/debruijn-graph-assembly/slides.html#46)

---

.enlarge120[

# **Assembly basics : Challenges of genome (and transcriptome) assembly**

]

[![Graphic shown three different assemblies, all tangled knots of sequences that will be very difficult to resolve.](../../images/illumina_graph_comparison.png)](https://github.com/rrwick/Unicycler)

Genome assembly is a difficult task. In trying to explain it we will be relying on two highly regarded sources:

- [Ben Langmead's Teaching Materials](http://www.langmead-lab.org/teaching-materials/)
- [Pevzner and Compeau Bioinformatics Book](https://www.goodreads.com/book/show/22033056-bioinformatics-algorithms).


---

.enlarge120[

# **Genomes and reads: Strings and *k*-mers**

]


## *k*-mer composition

Genomes are strings of text. When we sequence genomes we use sequencing machines that generate reads. For now let's assume that all reads have the same length *k* and every *k*-mer is sequenced only once. We will relax these assumptions later in this lecture. Thus sequencing a genome generates a large list of *k*-mers.

Suppose we are dealing with a *very* short genome `TATGGGGTGC`. Its *k*-mer composition (note the subscript) **Composition_k(Text)** is the collection of all *k*-mer substrings (including repeated ones). When *k* = 3 we get (basically we split sequence into windows of length 3 sliding window by 1 base every time):

&lt;samp&gt;
Composition_3(TATGGGGTGC)= ATG,GGG,GGG,GGT,GTG,TAT,TGC,TGG
&lt;samp&gt;


---


&lt;samp&gt;
Composition_3(TATGGGGTGC)= ATG,GGG,GGG,GGT,GTG,TAT,TGC,TGG
&lt;samp&gt;

Note that we have listed *k*-mers in lexicographic order (i.e., how they would appear in a dictionary) rather than in the order of their appearance in &lt;code&gt;TATGGGGTGC&lt;/code&gt;. We have done this because the correct ordering of the reads is unknown when they are generated (i.e., a sequencing machine does not generate reads in any particular order).


---

## Assembly by overlap

In the example above we know what the &quot;genome&quot; sequence is. In real life we don't know that and our goal is to determine genome sequence given a scrambled collection of *k*-mers. Let's consider the following collection of 3-mers representing a hypothetical genome:

&lt;code&gt; AAT ATG GTT TAA TGT &lt;/code&gt;

Let's &quot;tile&quot; k-mers if they overlap in k-1 nucleotides:

```
TAA
 AAT
  ATG
   TGT
    GTT
-------
TAATGTT
```

---

Now let's apply it to slightly longer &quot;genome&quot; with the following 3-mer composition sorted in a lexicographic order:

&lt;code&gt;
AAT ATG ATG ATG CAT CCA GAT GCC GGA GGG GTT TAA TGC TGG TGT
&lt;/code&gt;

`TAA` looks like a great beginning and we are continuing:
```
1 TAA
2  AAT
3   ATG
4    TGT
5     GTT
  -------
  TAATGTT
```

There is nothing in the original 3-mer composition, which starts with `TT`.

---

Let's track back and instead of `TGT` in step 4 insert `TGC`:

```
 1 TAA
 2  AAT
 3   ATG
 4    TGC
 5     GCC
 6      CCA
 7       CAT
 8        ATG
 9         TGG
10          GGA
11           GAT
12            ATG
13             TGT
14              GTT
   ----------------
   TAATGCCATGGATGTT
```

We only used 14 3-mers from the total of 15, so our genome is shorter (we have extra parts!). This difficulty is related to the fact that there are three repeated `ATG` motifs in this genome and as a result each `ATG` can be extended by either `TGG`, `TGC`, or `TGT`.

---

## The concept of coverage

*Coverage* is the number of reads covering a particular position in the genome. For example, in the following case:

```
TAA
 AAT
  ATG     &lt;- &quot;reads&quot; (15 bases total)
   TGT
    GTT
-------
TAATGTT   &lt;- &quot;genome&quot; (7 bases)
-------
0123456
```
The *Coverage* at positions 1 and 6 is *1*, at positions 1 and 5 is *2*, and at position 2, 3, and 4 is *3*. &lt;br&gt;The *Average Coverage* will be 15/7 ~ 2x


---

Below is another, slightly more realistic example where average coverage is 177/35 ~ 7x:

```
                  CTAGGCCCTCAATTTTT
                CTCTAGGCCCTCAATTTTT
              GGCTCTAGGCCCTCATTTTTT
           CTCGGCTCTAGCCCCTCATTTT
        TATCTCGACTCTAGGCCCTCA         &lt;- 177 bases
        TATCTCGACTCTAGGCC
    TCTATATCTCGGCTCTAGG
GGCGTCTATATCTCG
GGCGTCGATATCT
GGCGTCTATATCT
-----------------------------------
GGCGTCTATATCTCGGCTCTAGGCCCTCATTTTTT   &lt;- 35 bases
-----------------------------------
|         |         |         |   |
0         10        20        30  34
```

---

# The First and the Second laws of assembly

The goal of assembly process is to reconstruct an unknown genome sequence given a collection of scrambled sequencing reads:

```
CTAGGCCCTCAATTTTT
CTCTAGGCCCTCAATTTTT
GGCTCTAGGCCCTCATTTTTT
CTCGGCTCTAGCCCCTCATTTT
TATCTCGACTCTAGGCCCTCA                 &lt;- Reads (Given)
TATCTCGACTCTAGGCC
TCTATATCTCGGCTCTAGG
GGCGTCTATATCTCG
GGCGTCGATATCT
GGCGTCTATATCT
-----------------------------------
???????????????????????????????????   &lt;- Genome (Unknown)
```
&gt;    **The goal of assembly process**. Given sequencing reads reconstruct underlying genome sequence.

 We've seen that this can (in principle) be accomplished by finding overlaps. We also discussed the concept of the coverage.  We can now formulate the two first assembly laws.

---

## The First Assembly Law: Overlaps imply co-location

Let's define terms **Prefix** and **Suffix** using string &lt;code&gt;TAA&lt;/code&gt; as an example:

 * &lt;code&gt;Prefix(TAA) = TA&lt;/code&gt;
 * &lt;code&gt;Suffix(TAA) = AA&lt;/code&gt;

---

The First law states that if a *suffix* of one read is similar to a *prefix* of another read...

```
TCTATATCTCGGCTCTAGG    &lt;- read 1
    ||||||| |||||||
    TATCTCGACTCTAGGCC  &lt;- read 2
```

...then they may overlap (may be derived from the same location) within the genome.

```
      TCTATATCTCGGCTCTAGG                  &lt;- read 1
 -------------------------------------
 AGCGTTCTATATCTCGGCTCTAGGCCGTGCAGGACGT     &lt;- genome
 -------------------------------------
          TATCTCGACTCTAGGCC                &lt;- read 2
```

---

Note that in the above example suffix of the first read is *not* exactly identical to the prefix of the second read: they differ by a G-to-A substitution. Such differences are quite common in real life and may be caused by:

* **sequencing errors** - experimental or computational artifacts of DNA sequencing procedures.
* **allelic differences** - organisms such as human are diploid (and others, such as wheat are hexaploid) which maternal and paternal genomes being different at a number of genomic sites.
* **polymorphic sites** - DNA that is being sequenced is usually isolated from a large number of cells (e.g., white blood cells) or individuals (bacterial and viral cultures). Natural variation present in these cell (or viral particle) populations will manifest itself as these differences.

---

## The Second Assembly Law: The higher the coverage, the better

The Second law states that higher coverage leads to more frequent and longer overlaps:

```
                   CTAGGCCCTCAATTTTT
         TATCTCGACTCTAGGCCCTCA         &lt;- Low coverage
 GGCGTCTATATCT
 -----------------------------------
 GGCGTCTATATCTCGGCTCTAGGCCCTCATTTTTT   &lt;- Genome
 -----------------------------------
                   CTAGGCCCTCAATTTTT
                 CTCTAGGCCCTCAATTTTT
               GGCTCTAGGCCCTCATTTTTT
            CTCGGCTCTAGCCCCTCATTTT
         TATCTCGACTCTAGGCCCTCA         &lt;- Higher coverage
         TATCTCGACTCTAGGCC
     TCTATATCTCGGCTCTAGG
 GGCGTCTATATCTCG
 GGCGTCGATATCT
 GGCGTCTATATCT
```

---

# Solving assembly problem with graphs

We can solve assembly challenge using overlaps between sequencing reads. However, to solve this problem effectively we need to first represent all overlaps in a way that would facilitate further analysis. *Directed graphs* help achieving this.

---

## Directed graphs

Finding overlaps is identical to building a *directed graph* where directed *edges* connect *nodes* representing overlapping reads:
![Cartoons of two sequences aligned with nearly perfect matches. On the right are a list of nodes representing sequences. The two from the alignment are linked with an arrow and the text reads Suffix of source is similar to prefix of sink.](../../images/dag.png)

&gt;**Directed graph** representing overlapping reads. (Image from [Ben Langmead](http://www.cs.jhu.edu/~langmea/resources/lecture_notes/assembly_scs.pdf)).

---

For example, the string reconstruction we have seen earlier (with the difference of inserting `GGG` in line 10):

```
 1 TAA
 2  AAT
 3   ATG
 4    TGC
 5     GCC
 6      CCA
 7       CAT
 8        ATG
 9         TGG
10          GGG
11           GGA
12            GAT
13             ATG
14              TGT
15               GTT
   -----------------
   TAATGCCATGGGATGTT
```

can be represented as a following directed graph (or genome path):

![Graph where each of the above 3-mers is a single node in a graph and they are linked together from left to right most 3-mer.](../../images/4.6.png)

**Genome path**. Trimers composing the &lt;code&gt;TAATGCCATGGGATGTT&lt;/code&gt; sequence represented as the &quot;genome&quot; path. (Fig. 4.6 from [CP](http://bioinformaticsalgorithms.com/)). In this path a suffix of a 3-mer is equal to prefix of the next 3-mer.

---



**However**, we do not know the actual genome! All we have in real life is a collection of reads. Let's first build an overlap graph by connecting two 3-mers if suffix of one is equal to the prefix of the other:


&gt;![Th above graph is expanded to include a lot more connections between any nodes that share 2 base overlap.](../../images/4.7.png)
&gt;
&gt;**Overlap graph**. All possible overlap connections for our 3-mer collection. (Fig. 4.7 from [CP](http://bioinformaticsalgorithms.com/))

So to determine the sequence of the underlying genome we are looking a path in this graph that visits every node (3-mer) once. Such path is called [Hamiltonian path](https://en.wikipedia.org/wiki/Hamiltonian_path) and it may not be unique.

---

For example for our 3-mer collection there are two possible Hamiltonian paths:

![The above graph is re-used but a single path is highlighted](../../images/4.9a.png)
![The same graph with a different path highlighted.](../../images/4.9b.png)

**Two Hamiltonian paths for the 15 3-mers**. Edges spelling &quot;genomes&quot; &lt;code&gt;TAATGCCATGGGATGTT&lt;/code&gt; and &lt;code&gt;TAATGGGATGCCATGTT&lt;/code&gt; are highlighted in black. (Fig. 4.9. from [[CP](http://bioinformaticsalgorithms.com/)](http://bioinformaticsalgorithms.com/)).

---

The reason for this &quot;duality&quot; is the fact that we have a *repeat*: 3-mer &lt;code&gt;ATG&lt;/code&gt; is present three times in our data (&lt;font color=&quot;green&quot;&gt;green&lt;/font&gt;, &lt;font color=&quot;red&quot;&gt;red&lt;/font&gt;, and &lt;font color=&quot;blue&quot;&gt;blue&lt;/font&gt;). As we will see later repeats cause a lot of trouble in genome assembly.

---

## Finding overlaps

In the example above we had a collection of 3-mers and were always looking for overlaps of length two. In real life things may not be so &quot;regular&quot;. Suppose we have two reads:

```
Read X CTCTAGGCC
Read Y TAGGCCCTC
```
What is the overlap between these two reads? For now we will define overlap of &lt;code&gt;length - l&lt;/code&gt; suffix of Read X matches &lt;code&gt;length - l&lt;/code&gt; prefix of Read Y, where &lt;code&gt;l&lt;/code&gt; is given. To find these overlap we look in Read Y for instances &lt;code&gt;length - l&lt;/code&gt; suffix of Read X.

---

We will start with some minimal match of length $k$. Once a match is found it will be extended to the left to verify that the entire prefix of Read Y matches:

&gt;![Two sequences are shown X and Y. The X sequence ends with the string GCC. In Y they start looking from the end until they find a GCC. In this case we confirm a length-6 prefix of Y matches a suffix of X.](../../images/find_overlap.png)
&gt;
&gt;**Finding overlaps** between Read X and Read Y (Image from [Ben Langmead](http://www.cs.jhu.edu/~langmea/resources/lecture_notes/assembly_scs.pdf)).

---

As a result we represent two reads are connected nodes:
&gt;
&gt;![Node labelled with one sequence points to another. The sequences are the ones from above with the number 6 on the arrow between them.](../../images/og1.png)
&gt;
&gt;Number above the edge shows the length of the overlap.

While with just two reads the problem may seen quite straightforward. Let now consider a set of reads representing a very short genome &lt;code&gt;GTACGTACGAT&lt;/code&gt;:

```
GTACGT
TACGTA
CGTACG
ACGTAC
GTACGA
TACGAT
```

---

Building an overlap graph with overlap of &lt;code&gt;length &gt;= 4&lt;/code&gt; will give us the following:

&gt;![The overlap graph now has longer sequences and numbers annotating the length of the overlap](../../images/og2.png)
&gt;
&gt;You can see that there is a path through this graph that would spell out the original genome sequence &lt;code&gt;GTACGTACGAT&lt;/code&gt; :
&gt;
&gt;![The optimal, highest scoring path is represented through this graph](../../images/og3.png)
&gt;
&gt;Here we are lucky enough to have all nodes having a single outgoing edge with the highest number (the length of overlap).

---

## The Shortest Common Superstring Problem

The problem of reconstructing genome using the overlap graph that we have just illustrated can be initially formulated as the *Shortest Common Superstring (SCS)* problem. It states: *given a collection of strings S, find SCS(S), which is the shortest string that contains all strings from the set S as substrings*.

For simplicity let's suppose that we have the following set of strings &lt;code&gt;S&lt;/code&gt;:

&lt;samp&gt;
BAA AAB BBA ABA ABB BBB AAA BAB
&lt;/samp&gt;

One way of getting a string that would contain all of these as substrings will simply be concatenating them:

&lt;samp&gt;
Concat(S): BAAAABBBAABAABBBBBAAABAB (length = 24)
&lt;/samp&gt;


This, however, is not the *shortest* superstring that contains all strings from $S$. Instead the SCS is (just trust us here):

&lt;samp&gt;
SCS(S):: AAABBBABAA (length = 10)
&lt;/samp&gt;



---

It looks like finding SCS for a set of sequencing reads may just be what we need to produce a genome assembly. But how can this work in practice? One potential idea is to order the strings in some way and &quot;reduce&quot; them into a superstring (following examples are from Ben Langmead):

&gt;![A sequence of As and Bs in groups of 3s is labelled order 1. Below the sequence is written AAA, the current superstring.](../../images/scs1.png)

&gt;Let's look at the first two strings. They can be &quot;reduced&quot; to `AAAB`:
&gt;
&gt;![Now AAAB is written below the sequence because of the overlap in the first two groups.](../../images/scs2.png)
&gt;
&gt;The next two add an `A`:
&gt;
&gt;![Now AAABA is written, due to overlap in the second and third groups](../../images/scs3.png)
&gt;
&gt;Third and fourth add `BB`:
&gt;
&gt;![The extension process continues with another overlapping component extending it further.](../../images/scs4.png)

---

&gt;Continuing this we will eventually get `AAABABBAABABBABB`:
&gt;
&gt;![Order 1 produces a longish superstring](../../images/scs5.png)
&gt;
&gt;But `AAABABBAABABBABB` is the shortest only for this particular ordering. So let's reorder and try again:
&gt;
&gt;![Order 2, a new ordering of the same sequences, produces a shorter superstring.](../../images/scs6.png)
&gt;
&gt;Now we did better, but maybe we can do even better.

Ultimately we need to try all possible ordering and pick the shortest among all. Using this approach is we have &lt;code&gt;S&lt;/code&gt; strings we will need to do &lt;code&gt;S!&lt;/code&gt; tries. This can quickly get impossible. For our set of
eight strings &lt;code&gt;8! = 40320&lt;/code&gt;. If we get, say, a 1,000,000 reads from an Illumina machine then the factorial of a million is not going to be an attractive analysis option.

---

## Shortest common superstring: Greedy approach

As we've seen it will be impossible to assemble the genome using SCS logic. There is a simplification called *Greedy* approach to SCS problem. Let's take the following set of &quot;reads&quot;:

&lt;samp&gt;
AAA AAB ABB BBA BBB
&lt;/samp&gt;

and first build an overlap graph:

&gt;![Graph showing 5 nodes with various scores between them.](../../images/greedy1.png)
&gt;
&gt;**An overlap graph** for set &lt;code&gt;S: AAA AAB ABB BBA BBB&lt;/code&gt;.

---

Next, we start collapsing the nodes to maximize the overlap (and hence to decrease the length of the SCS we are trying to construct):

&gt;In the graph below there are multiple ties: nodes with outgoing edges of identical weights (e.g., edges pointing from `ABB` to both `BBA` and `BBB` have weight of two. Remember, that the weight is the length of overlap between two nodes' labels). In this situation we will break ties by randomly picking an edge to traverse. Let's pick &lt;font color=&quot;red&quot;&gt;`AAA` &amp;#8594; `AAB`&lt;/font&gt;:

&gt;![The above graph however the node AAA -&gt; 2 -&gt; AAB is highlighted in red.](../../images/greedy2.png)

---

.pull-left[
&gt;We then merge `AAA` and `AAB` into an SCS containing both, which will be `AAAB`:
&gt;
&gt;![The above graph however with 4 nodes, as AAA and AAB are merged](../../images/greedy3.png)
]
--
.pull-right[
&gt;Now let's pick edge &lt;font color=&quot;red&quot;&gt;`ABB` &amp;#8594; `BBB`&lt;/font&gt;:

&gt;![Another edge scoring 2 is highlighted, ABB to BBB (2)](../../images/greedy4.png)
]
---

.pull-left[
&gt;Collapse the nodes:
&gt;
&gt;![They're collapsed, now with 3 nodes in the graph](../../images/greedy5.png)
]
--
.pull-right[
&gt;Pick &lt;font color=&quot;red&quot;&gt;`ABBB` &amp;#8594; `BBA`&lt;/font&gt;:
&gt;
&gt;![Same as before, another highlighted](../../images/greedy6.png)
]
---
.pull-left[
&gt;Collapse the nodes:
&gt;
&gt;![Same as before, down to 2 nodes with arrows going both directions between them. One scores 2, one scores 1.](../../images/greedy7.png)
]
--
.pull-right[
&gt;Pick &lt;font color=&quot;red&quot;&gt;`AAAB` &amp;#8594; `ABBBA`&lt;/font&gt;:
&gt;
&gt;![The AAAB to ABBBA is highlighted, scoring 2.](../../images/greedy8.png)
]
---

&gt;Collapse again and now we are left with a superstring of length 7:
&gt;
&gt;![A single node is left producing AAABBBA](../../images/greedy9.png)

The above procedure can be computed *very* quickly. But there is a catch: it does not guarantee that it will give us truly the shortest superstring. It really depends on how we choose edges.

---

Below is another example of using the same dataset in which we traverse graph in a slightly different way: &lt;br&gt;
--

.pull-left[
&gt;We start the same way as before by choosing &lt;font color=&quot;red&quot;&gt;`AAA` &amp;#8594; `AAB`&lt;/font&gt;:
&gt;
&gt;![THe graph resets to 5 nodes](../../images/greedy2.png)
]
--
.pull-right[
&gt;Merge `AAA` and `AAB`:
&gt;
&gt;![The same initial step](../../images/greedy3.png)
]

---
.pull-left[
&gt;But now we pick a different edge &lt;font color=&quot;red&quot;&gt;`ABB` &amp;#8594; `BBA`&lt;/font&gt;:
&gt;
&gt;![Now a different edge scoring 2 is picked, ABB to BBA](../../images/greedy4_alt.png)
]
--
.pull-right[
&gt;Collapsing these nodes dramatically changes the graph:
&gt;
&gt;![these are collapsed producing a three node graph. AAAB and ABBA have a score of 2, BBB is only connected to AAAB with a score of 1.](../../images/greedy5_alt.png)
]

---
.pull-left[
&gt;Now we pick &lt;font color=&quot;red&quot;&gt;`AAAB` &amp;#8594; `ABBA`&lt;/font&gt; as this is the edge with the highest weight:
&gt;
&gt;![The highest scoring edge is picked](../../images/greedy6_alt.png)
]
--
.pull-right[
&gt;Collapsing it produces two nodes that are not connected to each other:
&gt;
&gt;![AAABBA and BBB are left, unconnected.](../../images/greedy7_alt.png)
]
---

And the SCS of these two will be a concatenation `AAABBABBB` of length 9. Thus a greedy approach may produce different answers. However, it is a sufficient approximation as the superstring yielded this way will not be more than ~2.5 times longer than the true SCS ([Gusfield](https://www.goodreads.com/book/show/145058.Algorithms_on_Strings_Trees_and_Sequences) 16.17.1).

---

# The Third Law of Assembly: Repeats are Evil!

Let's again apply Greedy SCS to a different &quot;genome&quot;. Suppose we want to reconstruct the phrase:

&lt;samp&gt;
a_long_long_long_time
&lt;/samp&gt;

from all 6-mers that overlap by at least 3 characters. The list of 6-mers is:

```
ng_lon      _long_      a_long      long_l      ong_ti      ong_lo      long_t
g_long      g_time      ng_tim
```

---

An overlap graph will look like this:

&gt;![A large, messy graph with various portions fo the above sentence.](../../images/long.png)
&gt;
&lt;small&gt;**An overlap graph** for with overlap length &lt;code&gt; &gt;= 3&lt;code&gt;.&lt;/small&gt;

---

If we proceed with Greedy SCS we will follow the following trajectory through the graph:

&gt;![A greedy path is highlighted, all scoring 5.](../../images/long_opt.png)

---

To make things even clearer let's isolate the path:

![Irrelevant edges are removed.](../../images/long_opt_focus.png)

---

The total overlap here (the sum of edge weights) is 4+5+5+5+5+5+5+5+5=44 but it gives us `a_long_long_time` as the shortest superstring:


```
a_long
  long_l
   ong_lo
    ng_lon
     g_long
      _long_
       long_t
        ong_ti
         ng_tim
          g_time
----------------
a_long_long_time
```

---

We are missing one instance of 'long' in this string. The following graph shows the path that would return the *correct* string:

 &gt;![A less optimal path is shown that recovers the duplicated long](../../images/long_corr.png)

---

A path yielding the correct string with three repeats. The total overlap here is 5+3+3+5+4+4+5+5+5=39, which is *worse* than the previous path if our goal is to find the shortest superstring:

```
a_long
 _long_
    ng_lon
       long_l
        ong_lo
          g_long
            long_t
             ong_ti
              ng_tim
               g_time
---------------------
a_long_long_long_time
```

---


## Are we really looking for the shortest superstring?

As we've seen above the shortest common superstring (SCS) is:

1. **Difficult to obtain** as Greedy SCS algorithm does not guarantee finding it. So the answer we get may be longer than the real genome we are trying to assemble.

2. **May be shorter than we want** because if the genome contains repeats that are longer than the reads we are using, Greedy SCS will collapse them and make assembly shorter that the genome we are trying to get.

Let's talk about an alternative way to represent the relationship between *k*-mers that may give us a more efficient algorithm.

---

# de Bruijn graphs

[Nicolaas de Bruijn](https://en.wikipedia.org/wiki/Nicolaas_Govert_de_Bruijn) had a purely theoretical interest of constructing _k_-universal strings for an arbitrary value of _k_. A _k_-universal string contains every possible _k_-mer only once:

&gt;[![Screenshot of a box from a textbook with illegible text and a similar graph to the ABBA ones shown above.](../../images/deBruijn_txt.png)](http://www.nature.com/nbt/journal/v29/n11/abs/nbt.2023.html)
&gt;
&gt;**de Bruijn graph**. From [Compeau:2011](http://www.nature.com/nbt/journal/v29/n11/abs/nbt.2023.html)

---

This problem is equivalent to a string reconstruction problem we have been talking about above: finding a _k_-universal string is equivalent to finding a Hamiltonian path in an overlap graph constructed from all _k_-mers. Yet finding a Hamiltonian path in a really large graph (representing a real genome) is not a tractable problem as we have seen. Instead de Bruijn decided to represent _k_-mer composition in a graph using a slightly different logic. Again, suppose we have a &quot;genome&quot; &lt;ode&gt;TAATGCCATGGGATGTT&lt;/code&gt; split in a collection of 3-mers:

&lt;samp&gt;
TAA AAT ATG TGC GCC CCA CAT ATG TGG GGG GGA GAT ATG TGT GTT
&lt;/samp&gt;

---

We will assign 3-mers to _edges_ instead of _nodes_:


![A long string of 2-mer nodes linked together with 3-mers on edges.](../../images/4.12.png)

**_k_-mers as edges**. Edges represented by 3-mers connect nodes representing the overlaps. (Fig. 4.12 from [CP](http://bioinformaticsalgorithms.com/))

This graph can be simplified by gluing identical nodes together:

![The same graph](../../images/4.13a.png)

![Re-organised to collapse identical nodes, first the AT node is collapsed from three into one.](../../images/4.13b.png)

---


Here the complexity of the graph is reduced by first gluing redundant &lt;font color=&quot;red&quot;&gt;`AT`&lt;/font&gt; nodes

![Now the 3 TG nodes are highlighted](../../images/4.13c.png)

![and collapsed into a single one, sharing the original's connections.](../../images/4.13d.png)

---

Next, &lt;font color=&quot;blue&quot;&gt;`TG`&lt;/font&gt; nodes are merged

![2 GG nodes are highlighted](../../images/4.13e.png)

![and merged, including a self-link.](../../images/4.13f.png)

---

And, finally the two &lt;font color=&quot;green&quot;&gt;`GG`&lt;/font&gt; nodes are resolved. (Fig. 4.13 from [CP](http://bioinformaticsalgorithms.com/))

Because we now represent _k_-mers as edges (rather than nodes), our problem has morphed into finding a path that visits every _edge_ once, or an [Eulerian Path](https://en.wikipedia.org/wiki/Eulerian_path):

![The final graph, same as previous image but now edges are numbered as well.](../../images/4.15.png)

**Eulerian paths for the 15 3-mers**. Numbering of edges provides a way to reconstruct the original &quot;genome&quot;. (Fig. 4.15 from [CP](http://bioinformaticsalgorithms.com/))

---

## Euler's Theorem

Some definitions:

 * **Balanced node** - a node where the number of incoming edges is equal to the number of outgoing edges
 * **Balanced graph** - a graph where all nodes are balanced
 * **Strongly connected graph** - any node can be reached from any other node


**Euler's Theorem**:

&gt;Every balanced, strongly connected directed graph is Eulerian.

---

Let's apply Euler's Theorem to a classical problem: The bridges of Königsberg problem. Here the question is: *Can you walk through all of Königsberg traversing every bridge exactly one time?* In other words: *Is there a Eulerian path through the city of Königsberg?*


&gt;![Old map of Königsberg with dots on land portions and links between them. This is reduced into the same coloured nodes and bridges representing edges.](../../images/koninsberg.png)
&gt;
&gt;**Königsberg and Euler's Theorem**. (a) A map of old Königsberg, in which each area of the city is labeled with a different color point. (b) The Königsberg Bridge graph, formed by representing each of four land areas as a node and each of the city's seven bridges as an edge. (From [Campeau:2011](http://www.nature.com/nbt/journal/v29/n11/abs/nbt.2023.html#close))

By looking at this graph we can see that it is *unbalanced*. If one arrives to, say, the &lt;font color=&quot;orange&quot;&gt;orange&lt;/font&gt; node from the &lt;font color=&quot;blue&quot;&gt;blue&lt;/font&gt; node there are two ways to get out. Thus there is no way to see all of the city and traverse every bridge once!

---

## Repeats are still a challenge

Let's look at the de Bruijn graph from above again. But this time let's drop edge numbering and pretend that the genome is now really known to us (as is usually the case in real life):

&gt;![Similar graph as above but now edges are only labelled by sequences, no more numbers.](../../images/dg1.png)
&gt;
&gt;**Eulerian paths for the 15 3-mers**.

---

In the original sequence `TAATGCCATGGGATGTT` *k*-mer &lt;font color=&quot;red&quot;&gt;`AT`&lt;/font&gt; is present 3 times and *k*-mer &lt;font color=&quot;blue&quot;&gt;`TG`&lt;/font&gt; is found twice. Thus *multiple* Eulerian walks are now possible like this:

&gt;![Following a direct path from the one node without incoming connections, to TG node, choosing one of the three outgoing connections we go 'up'](../../images/dg2.png)
&gt;
&gt;**Possible path #1**. Here after we reach &lt;font color=&quot;blue&quot;&gt;`TG`&lt;/font&gt; node we turn **up**.

---

The above path spells out:

```
TAA
 AAT
  ATG
   TGC
    GCC
     CCA
      CAT
       ATG
        TGG
         GGG
          GGA
           GAT
            ATG
             TGT
              GTT
-----------------
TAATGCCATGGGATGTT
```

---

Yet there is an alternative:

&gt;![The same as above but this time going down to follow a different path](../../images/dg3.png)
&gt;
&gt;**Possible path #2**. Here after we reach &lt;font color=&quot;blue&quot;&gt;`TG`&lt;/font&gt; node we turn **dow**.


---

Which spells:

```
TAA
 AAT
  ATG
   TGG
    GGA
     GAT
      ATG
       TGC
        GCC
         CCA
          CAT
           ATG
            TGT
             GTT
----------------
TAATGGATGCCATGTT
```

Note how different these are:

```
TAATGCCATGGGATGTT

TAATGGATGCCATGTTT
```

and only one of them is correct. Repeats are evil!

---

## *k*-mer size affects repeat resolution

In the above example we have used *k*-mer size of 3. But what if we try 4 or 5? Below are De Bruijn graphs for different values of *k*:

#### *k* = 3

&gt;![The same graph as above, now in a different orientation. There are many connections](../../images/k2.png)

---

&gt;This is our original graph

#### *k* = 4

&gt;![There are now significantly fewer connections.](../../images/k3.png)
&gt;
&gt;Here complexity is decreasing, but we still have the problem with having `ATG` twice.

---




.pull-left[
#### *k* = 5
In this case there is only one path. This because our *k* is larger that the repeat size, so we can resolve it accurately.

This is why technologies producing long sequencing reads stimulate so much enthusiasm - they will allow to resolve and produce accurate assembly of large genomes.
]
.pull-right[
![Graph with only a single route through the sequence.](../../images/k4.png)
]

---

# Assembly in real life

In this topic we've learned about two ways of representing the relationship between reads derived from a genome we are trying to assemble:

1. **Overlap graphs** - nodes are reads, edges are overlaps between reads.
2. **De Bruijn graphs** - nodes are overlaps, edges are reads.

&gt;![Overlap: graph from before, nodes are 3-mers, unlabelled connections.](../../images/4.7.png)

---

**A**.

![De Bruijn: The 2-mer graph with 3-mer connections again.](../../images/4.13f.png)

---

**B.**
An overlap (A) and De Bruijn (B) graphs for the same string.

Whatever the representation will be it will be messy:

![A hypothetical real life graph with a huge number of nodes snaking all over the screen, and many many isolaed single and pairs of nodes unconnected to anything.](../../images/t12_mess.png)

A fragment of a very large De Bruijn graph (Image from [BL](https://github.com/BenLangmead/ads1-slides/blob/master/0580_asm__practice.pdf)).

---


There are multiple reasons for such messiness:

**Sequence errors**

Sequencing machines do not give perfect data. This results in spurious deviations on the graph. Some sequencing technologies such as Oxford Nanopore have very high error rate of ~15%.

&gt;![An inset from the above. A red box highlights pairs of 2 and 3 node groups.](../../images/t12_errors.png)
&gt;
&gt;Graph components resulting from sequencing errors (Image from [BL](https://github.com/BenLangmead/ads1-slides/blob/master/0580_asm__practice.pdf)).

---

**Ploidy**

As we discussed earlier humans are diploid and there are multiple differences between maternal and paternal genomes. This creates &quot;bubbles&quot; on assembly graphs:

&gt;![A bubble in the graph. there are a series of nodes which have 5-8 connections pointing from one to the next. Halfway through there is a single base deviation and the 5-mer nodes highlight this single base change. The change results in a split into two strands which shortly reconnect. One strand is labelled Maternal, the other Paternal.](../../images/t12_bubble.png)
&gt;
&gt;Bubbles due to a heterozygous site  (Image from [BL](https://github.com/BenLangmead/ads1-slides/blob/master/0580_asm__practice.pdf)).

---

**Repeats**

As we've seen the third law of assembly is unbeatable. As a result some regions of the genome simply cannot be resolved and are reported in segments called *contigs*:

&gt;![A sentence is represented &quot;to everything turn&quot;, &quot;turn&quot; (a repeat) and &quot;turn there is a season&quot;. The repeat makes the graph hard to solve into a single path.](../../images/t12_contigs.png)
&gt;
&gt;The following &quot;genomic&quot; segment will be reported in three pieces corresponding to regions flanking the repeat and repeat itself (Image from [BL](https://github.com/BenLangmead/ads1-slides/blob/master/0580_asm__practice.pdf)).

---


.enlarge120[

# **How to perform Assembly with Galaxy?**

]

---

See the tutorial accompanied by these slides!




---
### &lt;i class=&quot;fas fa-key&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt;&lt;span class=&quot;visually-hidden&quot;&gt;keypoints&lt;/span&gt; Key points


- We learned about the strategies used by assemblers for hybrid assemblies

- We performed an hybrid assembly of a bacterial genome and its annotation

- Unicycler is a pipeline bases on Spades and Pilon dedicated to hybrid assembly of Small genomes

- Combination of short and long reads helped us produce an almost perfect assembly







---

## Thank You!

This material is the result of a collaborative work. Thanks to the [Galaxy Training Network](https://training.galaxyproject.org) and all the contributors!


<div class="contributors-line">

<a href="/training-material/hall-of-fame/nekrut/" class="contributor-badge contributor-nekrut"><img src="https://avatars.githubusercontent.com/nekrut?s=27" alt="Avatar">Anton Nekrutenko</a>


<a href="/training-material/hall-of-fame/delphine-l/" class="contributor-badge contributor-delphine-l"><img src="https://avatars.githubusercontent.com/delphine-l?s=27" alt="Avatar">Delphine Lariviere</a>


<a href="/training-material/hall-of-fame/slugger70/" class="contributor-badge contributor-slugger70"><img src="https://avatars.githubusercontent.com/slugger70?s=27" alt="Avatar">Simon Gladman</a>


</div>



<img src="/training-material/assets/images/GTN.png" alt="Galaxy Training Network" style="height: 100px;"/>


<a rel="license" href="https://creativecommons.org/licenses/by/4.0/">
This material is licensed under the Creative Commons Attribution 4.0 International License</a>.


    </textarea>
	<script src="/training-material/assets/js/remark-latest.min.js" type="text/javascript"></script>
    <script type="text/javascript" src="/training-material/assets/js/theme.js"></script>
    <script type="text/javascript" src="/training-material/assets/js/clipboard.min.js"></script>
    <script type="text/javascript">
      var slideshow = remark.create({navigation: {scroll: false}, ratio: '16:9'});
      var hljs = remark.highlighter.engine;
      var snippets = document.querySelectorAll('code.remark-code');
        [].forEach.call(snippets,function(snippet){
          snippet.firstChild.insertAdjacentHTML('beforebegin','<button class="btn btn-light" data-clipboard-snippet><i class="fa fa-copy"></i>&nbsp;Copy</button>');
        });
      var clipboardSnippets=new ClipboardJS('[data-clipboard-snippet]',{
        target:function(trigger){return trigger.parentElement;
      }});
    </script>

    <script type="text/javascript">
        if(window.location.hostname === "galaxyproject.github.io") {
            // Redirect
            var redirect = "https://training.galaxyproject.org" + window.location.pathname + window.location.search;
            $('body').prepend("<div style='text-align: center'><strong>Note: </strong>This content has a new home at <a href=\"" + redirect + "\">" + redirect + "</a>, which you will be redirected to in 5 seconds.</div>");

            window.setTimeout(function(){
                window.location.href = redirect;
            }, 5000)

        }
    </script>

  </body>
</html>
